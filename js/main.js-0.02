// main.js (further optimized: virtualization, lazy image loading, debounced snapshot handling, safe listeners)

// ⚠️ 请将您的 Firebase 配置对象粘贴到这里 ⚠️
const FIREBASE_CONFIG = {
    apiKey: "AIzaSyDqPJFaBp0x4ZBxXA46cAQ83iKx2NP6_Q4",
    authDomain: "seller-data-hgy.firebaseapp.com",
    projectId: "seller-data-hgy",
    storageBucket: "seller-data-hgy.firebasestorage.app",
    messagingSenderId: "663736276108",
    appId: "1:663736276108:web:f7dc897d49b342fbc217a9"
};

// 初始化 Firebase（保持 compat）
if (!firebase.apps.length) {
    firebase.initializeApp(FIREBASE_CONFIG);
}
const auth = firebase.auth();
const db = firebase.firestore();

// --- DOM 元素 (unchanged) ---
const authContainer = document.getElementById('auth-container');
const mainContainer = document.getElementById('main-container');
const loginForm = document.getElementById('login-form');
const authError = document.getElementById('auth-error');
const logoutBtn = document.getElementById('logout-btn');
const storesTab = document.getElementById('stores-tab');
const keywordsTab = document.getElementById('keywords-tab');
const productsTab = document.getElementById('products-tab');
const storesView = document.getElementById('stores-view');
const keywordsView = document.getElementById('keywords-view');
const productsView = document.getElementById('products-view');
const loadingSkeleton = document.getElementById('loading-skeleton');

const storeTableBody = document.getElementById('store-table-body');
const storeNoData = document.getElementById('stores-no-data');
const keywordTableBody = document.getElementById('keyword-table-body');
const keywordNoData = document.getElementById('keywords-no-data');
const productTableBody = document.getElementById('product-table-body');
const productNoData = document.getElementById('products-no-data');

const storeCountSpan = document.getElementById('store-count');
const keywordCountSpan = document.getElementById('keyword-count');
const productCountSpan = document.getElementById('product-count');

const ratingHeader = document.getElementById('rating-header');
const keywordDateHeader = document.getElementById('keyword-date-header');
const productDateHeader = document.getElementById('product-date-header');

const storeFiltersDiv = document.getElementById('store-filters');
const keywordFiltersDiv = document.getElementById('keyword-filters');
const productFiltersDiv = document.getElementById('product-filters');

const storeSearchInput = document.getElementById('store-search-input');
const keywordSearchInput = document.getElementById('keyword-search-input');
const productSearchInput = document.getElementById('product-search-input');

const storeImportBtn = document.getElementById('store-import-btn');
const storeImportFile = document.getElementById('store-import-file');
const storeExportBtn = document.getElementById('store-export-btn');
const storeSelectAll = document.getElementById('store-select-all');
const storeDeleteSelectedBtn = document.getElementById('store-delete-selected-btn');
const storeDownloadTemplateBtn = document.getElementById('store-download-template-btn');

const keywordImportBtn = document.getElementById('keyword-import-btn');
const keywordImportFile = document.getElementById('keyword-import-file');
const keywordExportBtn = document.getElementById('keyword-export-btn');
const keywordSelectAll = document.getElementById('keyword-select-all');
const keywordDeleteSelectedBtn = document.getElementById('keyword-delete-selected-btn');
const keywordDownloadTemplateBtn = document.getElementById('keyword-download-template-btn');

const productImportBtn = document.getElementById('product-import-btn');
const productImportFile = document.getElementById('product-import-file');
const productExportBtn = document.getElementById('product-export-btn');
const productSelectAll = document.getElementById('product-select-all');
const productDeleteSelectedBtn = document.getElementById('product-delete-selected-btn');
const productDownloadTemplateBtn = document.getElementById('product-download-template-btn');

const notificationContainer = document.getElementById('notification-container');

// --- Data stores using Map (incremental updates) ---
const storeData = new Map();
const keywordData = new Map();
const productData = new Map();

// --- Selection sets for O(1) ops ---
const selectedStoreIds = new Set();
const selectedKeywordIds = new Set();
const selectedProductIds = new Set();

// --- Sort/filter state ---
let storeSortKey = 'rating';
let storeSortDir = 'desc';
let keywordSortKey = 'date';
let keywordSortDir = 'desc';
let productSortKey = 'createdAt';
let productSortDir = 'desc';

let activeStoreSiteFilter = 'all';
let activeKeywordSiteFilter = 'all';
let activeProductSiteFilter = 'all';

// debounce timers for UI input and snapshot handling
let storeSearchTimer = null;
let keywordSearchTimer = null;
let productSearchTimer = null;
let snapshotDebounceTimer = null;

// store unsubscribe functions to avoid registering multiple listeners
let unsubscribers = {
    sellers: null,
    keywords: null,
    products: null
};

// Site map
const SITE_MAP = {
    "amazon.com": "US",
    "amazon.co.uk": "UK",
    "amazon.de": "DE",
    "amazon.fr": "FR",
    "amazon.es": "ES",
    "amazon.it": "IT",
    "amazon.co.jp": "JP",
    "amazon.ca": "CA",
    "amazon.com.au": "AU",
    "amazon.com.br": "BR",
    "amazon.com.mx": "MX",
    "amazon.in": "IN",
    "amazon.cn": "CN",
    "amazon.nl": "NL",
    "amazon.sg": "SG",
    "amazon.sa": "SA",
    "amazon.ae": "AE",
    "amazon.com.tr": "TR",
    "amazon.se": "SE",
    "amazon.pl": "PL",
    "amazon.com.eg": "EG",
    "amazon.com.be": "BE",
    "amazon.co.za": "ZA"
};
function getSiteAbbreviation(domain) {
    return SITE_MAP[domain] || domain;
}

// --- Notifications ---
function showNotification(message, type = 'success') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    notificationContainer.appendChild(notification);
    setTimeout(() => notification.remove(), 3000);
}

// --- Auth (unchanged) ---
loginForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const email = document.getElementById('login-email').value;
    const password = document.getElementById('login-password').value;
    try {
        await auth.signInWithEmailAndPassword(email, password);
        authError.textContent = '';
    } catch (error) {
        authError.textContent = '登录失败: ' + error.message;
    }
});
logoutBtn.addEventListener('click', () => auth.signOut());

auth.onAuthStateChanged((user) => {
    if (user) {
        authContainer.classList.add('hidden');
        mainContainer.classList.remove('hidden');
        showLoading();
        // ensure we register listeners only once
        startRealtimeListeners();
    } else {
        authContainer.classList.remove('hidden');
        mainContainer.classList.add('hidden');
        // clear data to free memory
        storeData.clear();
        keywordData.clear();
        productData.clear();
        // unsubscribe snapshots if any
        stopRealtimeListeners();
    }
});

function showLoading() {
    loadingSkeleton.classList.remove('hidden');
    storesView.classList.add('hidden');
    keywordsView.classList.add('hidden');
    productsView.classList.add('hidden');
}
function hideLoading() {
    loadingSkeleton.classList.add('hidden');
    if (storesTab.classList.contains('active')) storesView.classList.remove('hidden');
    else if (keywordsTab.classList.contains('active')) keywordsView.classList.remove('hidden');
    else productsView.classList.remove('hidden');
}

// --- Snapshot handling with debounce and incremental updates ---
function startRealtimeListeners() {
    // If already listening, do nothing
    if (unsubscribers.sellers || unsubscribers.keywords || unsubscribers.products) return;

    const applyChangesToMap = (docChanges, mapRef) => {
        docChanges.forEach(change => {
            if (change.type === 'added' || change.type === 'modified') {
                mapRef.set(change.doc.id, { id: change.doc.id, ...change.doc.data() });
            } else if (change.type === 'removed') {
                mapRef.delete(change.doc.id);
            }
        });
    };

    const debouncedProcess = () => {
        if (snapshotDebounceTimer) clearTimeout(snapshotDebounceTimer);
        snapshotDebounceTimer = setTimeout(() => {
            processStoreData(); processKeywordData(); processProductData();
            hideLoading();
        }, 120); // batch small bursts of snapshot changes
    };

    unsubscribers.sellers = db.collection('amazonSeller').onSnapshot(snapshot => {
        applyChangesToMap(snapshot.docChanges(), storeData);
        debouncedProcess();
    }, error => {
        console.error("获取店铺数据失败: ", error);
        showNotification("获取店铺数据失败，请检查控制台", 'error');
        hideLoading();
    });

    unsubscribers.keywords = db.collection('amazonKeywords').onSnapshot(snapshot => {
        applyChangesToMap(snapshot.docChanges(), keywordData);
        debouncedProcess();
    }, error => {
        console.error("获取关键词数据失败: ", error);
        showNotification("获取关键词数据失败，请检查控制台", 'error');
        hideLoading();
    });

    unsubscribers.products = db.collection('amazonProducts').onSnapshot(snapshot => {
        applyChangesToMap(snapshot.docChanges(), productData);
        debouncedProcess();
    }, error => {
        console.error("获取产品数据失败: ", error);
        showNotification("获取产品数据失败，请检查控制台", 'error');
        hideLoading();
    });
}

function stopRealtimeListeners() {
    if (unsubscribers.sellers) { unsubscribers.sellers(); unsubscribers.sellers = null; }
    if (unsubscribers.keywords) { unsubscribers.keywords(); unsubscribers.keywords = null; }
    if (unsubscribers.products) { unsubscribers.products(); unsubscribers.products = null; }
}

// --- Filtering & sorting helpers (return arrays on demand) ---
function getFilteredSortedStores() {
    const searchTerm = (storeSearchInput.value || '').toLowerCase();
    const arr = Array.from(storeData.values()).filter(item => {
        const siteMatch = activeStoreSiteFilter === 'all' || getSiteAbbreviation(item.site) === activeStoreSiteFilter;
        const searchMatch = !searchTerm || (item.sellerName && item.sellerName.toLowerCase().includes(searchTerm));
        return siteMatch && searchMatch;
    });
    arr.sort((a, b) => {
        let valA = a[storeSortKey], valB = b[storeSortKey];
        if (storeSortKey === 'rating') { valA = parseFloat(valA) || 0; valB = parseFloat(valB) || 0; }
        else if (storeSortKey === 'createdAt') { valA = a.createdAt ? new Date(a.createdAt) : 0; valB = b.createdAt ? new Date(b.createdAt) : 0; }
        if (valA < valB) return storeSortDir === 'asc' ? -1 : 1;
        if (valA > valB) return storeSortDir === 'asc' ? 1 : -1;
        return 0;
    });
    return arr;
}
function getFilteredSortedKeywords() {
    const searchTerm = (keywordSearchInput.value || '').toLowerCase();
    const arr = Array.from(keywordData.values()).filter(item => {
        const siteMatch = activeKeywordSiteFilter === 'all' || getSiteAbbreviation(item.site) === activeKeywordSiteFilter;
        const searchMatch = !searchTerm || (item.keyword && item.keyword.toLowerCase().includes(searchTerm)) || (item.keywordZh && item.keywordZh.toLowerCase().includes(searchTerm));
        return siteMatch && searchMatch;
    });
    arr.sort((a, b) => {
        let valA = a[keywordSortKey], valB = b[keywordSortKey];
        if (keywordSortKey === 'date') { valA = a.date ? new Date(a.date) : 0; valB = b.date ? new Date(b.date) : 0; }
        if (valA < valB) return keywordSortDir === 'asc' ? -1 : 1;
        if (valA > valB) return keywordSortDir === 'asc' ? 1 : -1;
        return 0;
    });
    return arr;
}
function getFilteredSortedProducts() {
    const searchTerm = (productSearchInput.value || '').toLowerCase();
    const arr = Array.from(productData.values()).filter(item => {
        const siteMatch = activeProductSiteFilter === 'all' || getSiteAbbreviation(item.site) === activeProductSiteFilter;
        const searchMatch = !searchTerm ||
            (item.productName && item.productName.toLowerCase().includes(searchTerm)) ||
            (item.productNameZh && item.productNameZh.toLowerCase().includes(searchTerm)) ||
            (item.asin && item.asin.toLowerCase().includes(searchTerm));
        return siteMatch && searchMatch;
    });
    arr.sort((a, b) => {
        let valA = a[productSortKey], valB = b[productSortKey];
        if (productSortKey === 'createdAt') { valA = a.createdAt ? new Date(a.createdAt) : 0; valB = b.createdAt ? new Date(b.createdAt) : 0; }
        if (valA < valB) return productSortDir === 'asc' ? -1 : 1;
        if (valA > valB) return productSortDir === 'asc' ? 1 : -1;
        return 0;
    });
    return arr;
}

// --- Debounced search inputs (lower render frequency) ---
storeSearchInput.addEventListener('input', () => {
    clearTimeout(storeSearchTimer);
    storeSearchTimer = setTimeout(() => renderStoreTable(), 200);
});
keywordSearchInput.addEventListener('input', () => {
    clearTimeout(keywordSearchTimer);
    keywordSearchTimer = setTimeout(() => renderKeywordTable(), 200);
});
productSearchInput.addEventListener('input', () => {
    clearTimeout(productSearchTimer);
    productSearchTimer = setTimeout(() => renderProductTable(), 200);
});

// --- Site filters rendering (lightweight) ---
function renderSiteFilters(container, dataArray, type) {
    container.innerHTML = '';
    const sites = new Set(dataArray.map(item => getSiteAbbreviation(item.site)).filter(site => site && site !== 'N/A'));
    const sortedSites = Array.from(sites).sort();
    const allBtn = document.createElement('button');
    allBtn.textContent = '全部站点';
    allBtn.classList.add('btn', 'filter-btn');
    const activeFilter = type === 'store' ? activeStoreSiteFilter : (type === 'keyword' ? activeKeywordSiteFilter : activeProductSiteFilter);
    if (activeFilter === 'all') allBtn.classList.add('active');
    allBtn.addEventListener('click', () => {
        if (type === 'store') activeStoreSiteFilter = 'all';
        else if (type === 'keyword') activeKeywordSiteFilter = 'all';
        else activeProductSiteFilter = 'all';
        renderXView(type);
        updateFilterButtonState(container, 'all');
    });
    container.appendChild(allBtn);
    sortedSites.forEach(site => {
        const btn = document.createElement('button');
        btn.textContent = site;
        btn.classList.add('btn', 'filter-btn');
        if (activeFilter === site) btn.classList.add('active');
        btn.addEventListener('click', () => {
            if (type === 'store') activeStoreSiteFilter = site;
            else if (type === 'keyword') activeKeywordSiteFilter = site;
            else activeProductSiteFilter = site;
            renderXView(type);
            updateFilterButtonState(container, site);
        });
        container.appendChild(btn);
    });
}
function updateFilterButtonState(container, activeSite) {
    container.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
    if (activeSite === 'all') container.querySelector('button')?.classList.add('active');
    else {
        const activeBtn = Array.from(container.querySelectorAll('button')).find(btn => btn.textContent === activeSite);
        if (activeBtn) activeBtn.classList.add('active');
    }
}
function renderXView(type) {
    if (type === 'store') renderStoreTable();
    else if (type === 'keyword') renderKeywordTable();
    else renderProductTable();
}

// --- Sorting handlers (same behavior) ---
function updateSortIcon(headerElement, sortDir) {
    const sortIcon = headerElement.querySelector('.sort-icon');
    if (sortIcon) {
        headerElement.closest('thead').querySelectorAll('.sort-icon').forEach(icon => {
            icon.textContent = '';
            icon.dataset.sortDir = '';
        });
        sortIcon.textContent = sortDir === 'asc' ? '▲' : '▼';
        sortIcon.dataset.sortDir = sortDir;
    }
}
ratingHeader.addEventListener('click', () => {
    storeSortDir = storeSortDir === 'desc' ? 'asc' : 'desc'; storeSortKey = 'rating';
    updateSortIcon(ratingHeader, storeSortDir); renderStoreTable();
});
keywordDateHeader.addEventListener('click', () => {
    keywordSortDir = keywordSortDir === 'desc' ? 'asc' : 'desc'; keywordSortKey = 'date';
    updateSortIcon(keywordDateHeader, keywordSortDir); renderKeywordTable();
});
productDateHeader.addEventListener('click', () => {
    productSortDir = productSortDir === 'desc' ? 'asc' : 'desc'; productSortKey = 'createdAt';
    updateSortIcon(productDateHeader, productSortDir); renderProductTable();
});

// --- Virtualization helper ---
// Simple generic virtualizer for table tbody; expects fixed rowHeight (px).
class VirtualTable {
    constructor(containerEl, tbodyEl, rowHeight = 48, buffer = 8) {
        this.container = containerEl; // .table-wrapper (scrollable)
        this.tbody = tbodyEl; // tbody element where rows will be rendered
        this.rowHeight = rowHeight;
        this.buffer = buffer; // number of extra rows before/after viewport
        this.onScroll = this.onScroll.bind(this);
        this.currentData = [];
        this.renderedRange = [0, -1];
        this.rafId = null;
        this.container.addEventListener('scroll', this.onScroll, { passive: true });
        // set explicit height if not present (will use CSS max-height)
        this.container.style.willChange = 'transform';
    }

    updateData(newData, renderRow) {
        // newData is an array, renderRow is function(item, index) => <tr>
        this.currentData = newData;
        // set tbody total height using a spacer trick:
        // we'll set a top spacer row height and bottom spacer row height via empty rows
        this.totalHeight = newData.length * this.rowHeight;
        // trigger immediate render for visible window
        this.scheduleRender(renderRow);
    }

    onScroll() {
        if (this.rafId) cancelAnimationFrame(this.rafId);
        this.rafId = requestAnimationFrame(() => this.scheduleRender(this.lastRenderRowFn));
    }

    scheduleRender(renderRow) {
        if (!renderRow) return;
        this.lastRenderRowFn = renderRow;
        const scrollTop = this.container.scrollTop;
        const height = this.container.clientHeight || this.container.offsetHeight;
        const startIdx = Math.max(0, Math.floor(scrollTop / this.rowHeight) - this.buffer);
        const visibleCount = Math.ceil(height / this.rowHeight) + this.buffer * 2;
        const endIdx = Math.min(this.currentData.length - 1, startIdx + visibleCount - 1);

        // if same range, skip rendering
        if (this.renderedRange[0] === startIdx && this.renderedRange[1] === endIdx) return;
        this.renderedRange = [startIdx, endIdx];

        // build fragment
        const frag = document.createDocumentFragment();
        for (let i = startIdx; i <= endIdx; i++) {
            const item = this.currentData[i];
            const tr = renderRow(item, i);
            frag.appendChild(tr);
        }

        // Clear and set spacer approach
        // We'll set tbody.innerHTML to two spacer rows + fragment in between.
        // Use minimal markup for spacers to avoid many DOM nodes.
        const topPad = startIdx * this.rowHeight;
        const bottomPad = Math.max(0, this.totalHeight - ((endIdx + 1) * this.rowHeight));

        // Create wrapper div to hold our rows and padding rows
        // For tables, TR elements must be direct children of TBODY. We'll create:
        // first a single empty tr with style height: topPad, then append fragment, then one empty tr for bottomPad.
        this.tbody.innerHTML = '';
        if (topPad > 0) {
            const topTr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 20; // large col span to cover table; okay since it's just a spacer
            td.style.height = topPad + 'px';
            td.style.padding = 0;
            td.style.border = 'none';
            topTr.appendChild(td);
            this.tbody.appendChild(topTr);
        }
        this.tbody.appendChild(frag);
        if (bottomPad > 0) {
            const bottomTr = document.createElement('tr');
            const td2 = document.createElement('td');
            td2.colSpan = 20;
            td2.style.height = bottomPad + 'px';
            td2.style.padding = 0;
            td2.style.border = 'none';
            bottomTr.appendChild(td2);
            this.tbody.appendChild(bottomTr);
        }
    }

    destroy() {
        this.container.removeEventListener('scroll', this.onScroll);
        if (this.rafId) cancelAnimationFrame(this.rafId);
        this.tbody.innerHTML = '';
    }
}

// Create virtualizers for the three tables
const storeVirtualizer = new VirtualTable(document.querySelector('#stores-view .table-wrapper'), storeTableBody, 48, 6);
const keywordVirtualizer = new VirtualTable(document.querySelector('#keywords-view .table-wrapper'), keywordTableBody, 48, 6);
const productVirtualizer = new VirtualTable(document.querySelector('#products-view .table-wrapper'), productTableBody, 72, 6); // product rows might be taller due to image

// IntersectionObserver for lazy-loading thumbnails and releasing them when off-screen
const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        const img = entry.target;
        if (entry.isIntersecting) {
            const src = img.dataset.src || img.dataset.large || img.getAttribute('data-large');
            if (src && img.src !== src) img.src = src;
        }
    });
}, { root: document, rootMargin: '200px', threshold: 0.01 });

// --- Render functions use virtualizer to only render visible rows ---
// Each renderRow returns a TR element (not appended)
function renderStoreRow(item, index) {
    const tr = document.createElement('tr');
    tr.dataset.id = item.id;
    if (selectedStoreIds.has(item.id)) tr.classList.add('selected');
    tr.innerHTML = `
        <td><input type="checkbox" class="store-checkbox" data-id="${item.id}" ${selectedStoreIds.has(item.id) ? 'checked' : ''}></td>
        <td>${index + 1}</td>
        <td data-tooltip="${item.site || 'N/A'}">${getSiteAbbreviation(item.site) || 'N/A'}</td>
        <td data-tooltip="${item.sellerName || 'N/A'}">${item.sellerName ? (item.sellerId && item.site ? `<a href="https://www.${item.site}/sp?ie=UTF8&seller=${item.sellerId}" target="_blank" rel="noreferrer noopener">${item.sellerName}</a>` : item.sellerName) : 'N/A'}</td>
        <td data-tooltip="${item.feedback || 'N/A'}">${item.feedback || 'N/A'}</td>
        <td data-tooltip="${item.rating || 'N/A'}">${item.rating || 'N/A'}</td>
        <td data-tooltip="${item.reviews || 'N/A'}">${item.reviews || 'N/A'}</td>
        <td data-tooltip="${item.BestSellers || 'N/A'}">${item.BestSellers || 'N/A'}</td>
        <td data-tooltip="${item.NewestArrivals || 'N/A'}">${item.NewestArrivals || 'N/A'}</td>
        <td><button class="btn secondary-btn delete-store-btn" data-id="${item.id}">删除</button></td>
    `;
    return tr;
}
function renderKeywordRow(item, index) {
    const tr = document.createElement('tr');
    tr.dataset.id = item.id;
    if (selectedKeywordIds.has(item.id)) tr.classList.add('selected');
    const keywordUrl = item.url || '#';
    const date = item.date || 'N/A';
    const hasUrl = keywordUrl !== '#';
    const keywordLink = hasUrl ? `<a href="${keywordUrl}" target="_blank" rel="noreferrer noopener">${item.keyword || 'N/A'}</a>` : (item.keyword || 'N/A');
    const keywordZhLink = hasUrl ? `<a href="${keywordUrl}" target="_blank" rel="noreferrer noopener">${item.keywordZh || 'N/A'}</a>` : (item.keywordZh || 'N/A');
    const countLink = hasUrl ? `<a href="${keywordUrl}" target="_blank" rel="noreferrer noopener">${item.count || 'N/A'}</a>` : (item.count || 'N/A');
    tr.innerHTML = `
        <td><input type="checkbox" class="keyword-checkbox" data-id="${item.id}" ${selectedKeywordIds.has(item.id) ? 'checked' : ''}></td>
        <td>${index + 1}</td>
        <td data-tooltip="${item.site || 'N/A'}">${getSiteAbbreviation(item.site) || 'N/A'}</td>
        <td data-tooltip="${item.keyword || 'N/A'}">${keywordLink}</td>
        <td data-tooltip="${item.keywordZh || 'N/A'}">${keywordZhLink}</td>
        <td data-tooltip="${item.count || 'N/A'}">${countLink}</td>
        <td data-tooltip="${date}">${date}</td>
        <td><button class="btn secondary-btn delete-keyword-btn" data-id="${item.id}">删除</button></td>
    `;
    return tr;
}
function renderProductRow(item, index) {
    const tr = document.createElement('tr');
    tr.dataset.id = item.id;
    if (selectedProductIds.has(item.id)) tr.classList.add('selected');
    const productUrl = item.url || '#';
    const hasUrl = productUrl !== '#';
    const asinLink = hasUrl ? `<a href="${productUrl}" target="_blank" rel="noreferrer noopener">${item.asin || 'N/A'}</a>` : (item.asin || 'N/A');
    const productNameLink = hasUrl ? `<a href="${productUrl}" target="_blank" rel="noreferrer noopener">${item.productName || 'N/A'}</a>` : (item.productName || 'N/A');
    const productNameZhLink = hasUrl ? `<a href="${productUrl}" target="_blank" rel="noreferrer noopener">${item.productNameZh || 'N/A'}</a>` : (item.productNameZh || 'N/A');
    const date = item.createdAt ? new Date(item.createdAt).toLocaleDateString() : 'N/A';
    const imageHtml = item.mainImageURL ? `
        <div class="product-image-container">
            <img data-src="${item.mainImageURL}" alt="Product Image" class="product-image-thumb" loading="lazy">
        </div>` : 'N/A';

    tr.innerHTML = `
        <td><input type="checkbox" class="product-checkbox" data-id="${item.id}" ${selectedProductIds.has(item.id) ? 'checked' : ''}></td>
        <td>${index + 1}</td>
        <td data-tooltip="${item.site || 'N/A'}">${getSiteAbbreviation(item.site) || 'N/A'}</td>
        <td data-tooltip="${item.asin || 'N/A'}">${asinLink}</td>
        <td>${imageHtml}</td>
        <td data-tooltip="${item.price || 'N/A'}">${item.price || 'N/A'}</td>
        <td data-tooltip="${item.productName || 'N/A'}">${productNameLink}</td>
        <td data-tooltip="${item.productNameZh || 'N/A'}">${productNameZhLink}</td>
        <td data-tooltip="${date}">${date}</td>
        <td><button class="btn secondary-btn delete-product-btn" data-id="${item.id}">删除</button></td>
    `;
    return tr;
}

// --- Table renderers using virtualizers ---
function renderStoreTable() {
    const rows = getFilteredSortedStores();
    storeNoData.classList.add('hidden');
    storeCountSpan.textContent = rows.length;
    storeDeleteSelectedBtn.disabled = selectedStoreIds.size === 0;
    if (rows.length === 0) {
        storeNoData.classList.remove('hidden');
        storeSelectAll.disabled = true; storeSelectAll.checked = false;
        storeVirtualizer.updateData([], renderStoreRow);
        return;
    } else storeSelectAll.disabled = false;

    storeVirtualizer.updateData(rows, (item, idx) => {
        const tr = renderStoreRow(item, idx);
        // don't attach listeners per row; use delegation
        return tr;
    });

    // set select-all based on visible (filtered) ids
    const filteredIds = rows.map(r => r.id);
    storeSelectAll.checked = filteredIds.length > 0 && filteredIds.every(id => selectedStoreIds.has(id));
}

function renderKeywordTable() {
    const rows = getFilteredSortedKeywords();
    keywordNoData.classList.add('hidden');
    keywordCountSpan.textContent = rows.length;
    keywordDeleteSelectedBtn.disabled = selectedKeywordIds.size === 0;
    if (rows.length === 0) {
        keywordNoData.classList.remove('hidden');
        keywordSelectAll.disabled = true; keywordSelectAll.checked = false;
        keywordVirtualizer.updateData([], renderKeywordRow);
        return;
    } else keywordSelectAll.disabled = false;

    keywordVirtualizer.updateData(rows, (item, idx) => renderKeywordRow(item, idx));
    const filteredIds = rows.map(r => r.id);
    keywordSelectAll.checked = filteredIds.length > 0 && filteredIds.every(id => selectedKeywordIds.has(id));
}

function renderProductTable() {
    const rows = getFilteredSortedProducts();
    productNoData.classList.add('hidden');
    productCountSpan.textContent = rows.length;
    productDeleteSelectedBtn.disabled = selectedProductIds.size === 0;
    if (rows.length === 0) {
        productNoData.classList.remove('hidden');
        productSelectAll.disabled = true; productSelectAll.checked = false;
        productVirtualizer.updateData([], renderProductRow);
        return;
    } else productSelectAll.disabled = false;

    productVirtualizer.updateData(rows, (item, idx) => {
        const tr = renderProductRow(item, idx);
        // Observe thumbnail for lazy load
        const thumb = tr.querySelector('.product-image-thumb');
        if (thumb) imageObserver.observe(thumb);
        return tr;
    });

    const filteredIds = rows.map(r => r.id);
    productSelectAll.checked = filteredIds.length > 0 && filteredIds.every(id => selectedProductIds.has(id));
}

// --- Event delegation for tables (single listeners) ---
// Stores
storeTableBody.addEventListener('click', (e) => {
    const row = e.target.closest('tr');
    if (!row) return;
    const id = row.dataset.id;
    if (e.target.classList.contains('delete-store-btn')) { deleteStore(id); return; }
    if (e.target.tagName.toLowerCase() === 'input' && e.target.classList.contains('store-checkbox')) return;
    const checkbox = row.querySelector('.store-checkbox');
    if (checkbox) { checkbox.checked = !checkbox.checked; checkbox.dispatchEvent(new Event('change', { bubbles: true })); }
});
storeTableBody.addEventListener('change', (e) => {
    if (!e.target.classList.contains('store-checkbox')) return;
    const id = e.target.dataset.id; const row = e.target.closest('tr');
    if (e.target.checked) { selectedStoreIds.add(id); row?.classList.add('selected'); }
    else { selectedStoreIds.delete(id); row?.classList.remove('selected'); }
    storeDeleteSelectedBtn.disabled = selectedStoreIds.size === 0;
    const currentFiltered = getFilteredSortedStores().map(i => i.id);
    storeSelectAll.checked = currentFiltered.length > 0 && currentFiltered.every(fid => selectedStoreIds.has(fid));
});

// Keywords
keywordTableBody.addEventListener('click', (e) => {
    const row = e.target.closest('tr'); if (!row) return;
    const id = row.dataset.id;
    if (e.target.classList.contains('delete-keyword-btn')) { deleteKeyword(id); return; }
    if (e.target.tagName.toLowerCase() === 'input' && e.target.classList.contains('keyword-checkbox')) return;
    const checkbox = row.querySelector('.keyword-checkbox');
    if (checkbox) { checkbox.checked = !checkbox.checked; checkbox.dispatchEvent(new Event('change', { bubbles: true })); }
});
keywordTableBody.addEventListener('change', (e) => {
    if (!e.target.classList.contains('keyword-checkbox')) return;
    const id = e.target.dataset.id; const row = e.target.closest('tr');
    if (e.target.checked) { selectedKeywordIds.add(id); row?.classList.add('selected'); }
    else { selectedKeywordIds.delete(id); row?.classList.remove('selected'); }
    keywordDeleteSelectedBtn.disabled = selectedKeywordIds.size === 0;
    const currentFiltered = getFilteredSortedKeywords().map(i => i.id);
    keywordSelectAll.checked = currentFiltered.length > 0 && currentFiltered.every(fid => selectedKeywordIds.has(fid));
});

// Products (also lazy large preview: click thumbnail to open full view)
productTableBody.addEventListener('click', (e) => {
    const row = e.target.closest('tr'); if (!row) return;
    const id = row.dataset.id;
    if (e.target.classList.contains('delete-product-btn')) { deleteProduct(id); return; }
    if (e.target.tagName.toLowerCase() === 'input' && e.target.classList.contains('product-checkbox')) return;
    // If clicked on thumbnail, open large preview (create only when needed)
    const thumb = e.target.closest('.product-image-thumb');
    if (thumb) {
        const url = thumb.dataset.src || thumb.getAttribute('data-src');
        if (url) showLargeImage(url);
        return;
    }
    const checkbox = row.querySelector('.product-checkbox');
    if (checkbox) { checkbox.checked = !checkbox.checked; checkbox.dispatchEvent(new Event('change', { bubbles: true })); }
});
productTableBody.addEventListener('change', (e) => {
    if (!e.target.classList.contains('product-checkbox')) return;
    const id = e.target.dataset.id; const row = e.target.closest('tr');
    if (e.target.checked) { selectedProductIds.add(id); row?.classList.add('selected'); }
    else { selectedProductIds.delete(id); row?.classList.remove('selected'); }
    productDeleteSelectedBtn.disabled = selectedProductIds.size === 0;
    const currentFiltered = getFilteredSortedProducts().map(i => i.id);
    productSelectAll.checked = currentFiltered.length > 0 && currentFiltered.every(fid => selectedProductIds.has(fid));
});

// --- Large image preview (create on demand) ---
let largeImageOverlay = null;
function showLargeImage(url) {
    removeLargeImage();
    largeImageOverlay = document.createElement('div');
    largeImageOverlay.className = 'product-image-overlay';
    const img = document.createElement('img');
    img.className = 'product-image-large';
    img.src = url;
    img.alt = 'Product Image Large';
    // append once
    document.body.appendChild(largeImageOverlay);
    document.body.appendChild(img);
    requestAnimationFrame(() => {
        largeImageOverlay.style.opacity = '1';
        img.style.transform = 'translate(-50%, -50%) scale(1)';
        img.style.opacity = '1';
        img.style.pointerEvents = 'auto';
    });
    const remover = () => removeLargeImage();
    largeImageOverlay.addEventListener('click', remover);
    img.addEventListener('click', remover);
}
function removeLargeImage() {
    const big = document.querySelector('.product-image-large');
    const overlay = document.querySelector('.product-image-overlay');
    if (big && big.parentNode) big.parentNode.removeChild(big);
    if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
    largeImageOverlay = null;
}

// --- CSV parsing (kept simple) ---
function parseCSV(text) {
    const lines = text.split('\n').filter(line => line.trim() !== '');
    if (!lines.length) return [];
    const headers = lines[0].split(',').map(h => h.trim());
    const data = [];
    for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.trim());
        if (values.length !== headers.length) { console.warn(`跳过格式不正确的行: ${lines[i]}`); continue; }
        const obj = {};
        for (let j = 0; j < headers.length; j++) obj[headers[j]] = values[j];
        data.push(obj);
    }
    return data;
}

// --- File import handler (unchanged logic but kept lean) ---
async function handleFileImport(event, collectionName, requiredKeys, successMessage) {
    const file = event.target.files[0]; if (!file) return;
    const fileExtension = file.name.split('.').pop().toLowerCase();
    const reader = new FileReader();
    reader.onload = async (e) => {
        const content = e.target.result;
        try {
            let data = null;
            if (fileExtension === 'json') {
                const trimmedContent = content.trim(); if (!trimmedContent) throw new Error('JSON 文件内容为空。');
                data = JSON.parse(trimmedContent);
            } else if (fileExtension === 'csv') {
                // For very large CSVs, consider integrating PapaParse streaming in future
                data = parseCSV(content);
            } else throw new Error('不支持的文件类型。请上传 JSON 或 CSV 文件。');

            if (!data || !Array.isArray(data)) throw new Error('导入的数据格式不正确，期望一个数组。');
            if (data.length > 0) {
                const firstItem = data[0];
                const missingKeys = requiredKeys.filter(k => !(k in firstItem));
                if (missingKeys.length > 0) throw new Error(`数据中缺少必要的字段: ${missingKeys.join(', ')}。`);
            }
            await importDataToFirestore(db.collection(collectionName), data);
            showNotification(successMessage, 'success');
        } catch (err) {
            console.error('文件解析失败:', err);
            showNotification(`文件解析失败：${err.message}`, 'error');
        }
    };
    reader.readAsText(file);
}

// --- Import to Firestore (keeps chunking logic) ---
async function importDataToFirestore(collectionRef, data) {
    if (!data.length) { showNotification('导入数据为空，操作取消。', 'info'); return; }
    const now = new Date().toISOString();
    const uniqueRecords = new Map();
    let importKeys = [];
    if (collectionRef.id === 'amazonSeller') importKeys = ['site', 'sellerId'];
    else if (collectionRef.id === 'amazonKeywords') importKeys = ['site', 'keyword'];
    else importKeys = ['asin'];
    for (const record of data) {
        const key = importKeys.map(k => record[k]).join('|');
        if (key) uniqueRecords.set(key, record);
    }
    if (!uniqueRecords.size) { showNotification('导入的数据中没有有效记录，操作取消。', 'info'); return; }
    const existingDocsMap = new Map();
    const CHUNK_SIZE = 30;
    if (collectionRef.id === 'amazonProducts') {
        const uniqueAsins = Array.from(new Set(Array.from(uniqueRecords.values()).map(r => r.asin)));
        for (let i = 0; i < uniqueAsins.length; i += CHUNK_SIZE) {
            const chunk = uniqueAsins.slice(i, i + CHUNK_SIZE);
            const snap = await collectionRef.where('asin', 'in', chunk).get();
            snap.forEach(doc => existingDocsMap.set(doc.data().asin, { id: doc.id, data: doc.data() }));
        }
    } else {
        const uniqueSites = Array.from(new Set(Array.from(uniqueRecords.values()).map(r => r.site)));
        const uniqueKeys = Array.from(new Set(Array.from(uniqueRecords.values()).map(r => r[importKeys[1]])));
        for (let i = 0; i < uniqueSites.length; i++) {
            const site = uniqueSites[i];
            for (let j = 0; j < uniqueKeys.length; j += CHUNK_SIZE) {
                const chunk = uniqueKeys.slice(j, j + CHUNK_SIZE);
                const snap = await collectionRef.where('site', '==', site).where(importKeys[1], 'in', chunk).get();
                snap.forEach(doc => {
                    const uid = `${doc.data().site}|${doc.data()[importKeys[1]]}`;
                    existingDocsMap.set(uid, { id: doc.id, data: doc.data() });
                });
            }
        }
    }
    // Commit in batches of up to 400 (safety below 500)
    const allRecords = Array.from(uniqueRecords.values());
    const BATCH_SIZE = 400;
    for (let i = 0; i < allRecords.length; i += BATCH_SIZE) {
        const chunk = allRecords.slice(i, i + BATCH_SIZE);
        const batch = db.batch();
        for (const record of chunk) {
            let uniqueId = collectionRef.id === 'amazonProducts' ? record.asin : importKeys.map(k => record[k]).join('|');
            const existingDoc = existingDocsMap.get(uniqueId);
            if (existingDoc) {
                const updatedItem = { ...existingDoc.data, ...record, updatedAt: now };
                batch.update(collectionRef.doc(existingDoc.id), updatedItem);
            } else {
                const newItem = { ...record, createdAt: now, updatedAt: now };
                batch.set(collectionRef.doc(), newItem);
            }
        }
        await batch.commit();
    }
    console.log("所有数据已成功导入。");
}

// --- Bind import/export/template buttons ---
storeImportBtn.addEventListener('click', () => storeImportFile.click());
storeImportFile.addEventListener('change', (e) => handleFileImport(e, 'amazonSeller', ['site', 'sellerId'], '店铺数据导入成功！'));
keywordImportBtn.addEventListener('click', () => keywordImportFile.click());
keywordImportFile.addEventListener('change', (e) => handleFileImport(e, 'amazonKeywords', ['site', 'keyword'], '关键词数据导入成功！'));
productImportBtn.addEventListener('click', () => productImportFile.click());
productImportFile.addEventListener('change', (e) => handleFileImport(e, 'amazonProducts', ['asin'], '产品数据导入成功！'));

function exportData(data, type, filename) {
    if (!data.length) { showNotification('无数据可导出。', 'error'); return; }
    let content = '', mimeType = '';
    if (type === 'json') { content = JSON.stringify(data, null, 2); mimeType = 'application/json'; }
    else if (type === 'csv') {
        const headers = Object.keys(data[0]).join(',');
        const rows = data.map(item => Object.values(item).map(v => (`${v || ''}`).replace(/"/g, '""')).map(v => `"${v}"`).join(','));
        content = [headers, ...rows].join('\n'); mimeType = 'text/csv';
    } else { showNotification('不支持的导出格式。', 'error'); return; }
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    showNotification('数据导出成功！', 'success');
}
storeExportBtn.addEventListener('click', () => exportData(getFilteredSortedStores(), 'csv', 'amazon_seller.csv'));
keywordExportBtn.addEventListener('click', () => exportData(getFilteredSortedKeywords(), 'csv', 'amazon_keywords.csv'));
productExportBtn.addEventListener('click', () => exportData(getFilteredSortedProducts(), 'csv', 'amazon_products.csv'));

function downloadTemplate(keys, filename) {
    const templateData = [{ ...keys.reduce((acc, key) => (acc[key] = '', acc), {}) }];
    exportData(templateData, 'csv', filename);
}
storeDownloadTemplateBtn.addEventListener('click', () => downloadTemplate(['sellerId', 'site', 'sellerName', 'feedback', 'rating', 'reviews', 'BestSellers', 'NewestArrivals'], 'stores_template.csv'));
keywordDownloadTemplateBtn.addEventListener('click', () => downloadTemplate(['keyword', 'site', 'keywordZh', 'url', 'count', 'date'], 'keywords_template.csv'));
productDownloadTemplateBtn.addEventListener('click', () => downloadTemplate(['asin', 'site', 'productName', 'productNameZh', 'price', 'mainImageURL'], 'products_template.csv'));

// --- Deletion utilities ---
async function deleteData(collectionName, ids) {
    if (!ids || ids.length === 0) { showNotification('未选择任何项。', 'info'); return; }
    const confirmMessage = `您确定要删除选中的 ${ids.length} 条数据吗？此操作无法撤销。`;
    if (!confirm(confirmMessage)) return;
    try {
        const batch = db.batch();
        ids.forEach(id => batch.delete(db.collection(collectionName).doc(id)));
        await batch.commit();
        showNotification('数据删除成功！', 'success');
    } catch (err) { console.error("删除失败: ", err); showNotification('删除失败，请检查控制台。', 'error'); }
}
async function deleteStore(id) {
    if (!confirm("您确定要删除这条店铺数据吗？此操作无法撤销。")) return;
    try { await db.collection('amazonSeller').doc(id).delete(); showNotification('店铺数据删除成功！', 'success'); selectedStoreIds.delete(id); }
    catch (err) { console.error("删除失败: ", err); showNotification('删除失败，请检查控制台。', 'error'); }
}
async function deleteKeyword(id) {
    if (!confirm("您确定要删除这条关键词数据吗？此操作无法撤销。")) return;
    try { await db.collection('amazonKeywords').doc(id).delete(); showNotification('关键词数据删除成功！', 'success'); selectedKeywordIds.delete(id); }
    catch (err) { console.error("删除失败: ", err); showNotification('删除失败，请检查控制台。', 'error'); }
}
async function deleteProduct(id) {
    if (!confirm("您确定要删除这条产品数据吗？此操作无法撤销。")) return;
    try { await db.collection('amazonProducts').doc(id).delete(); showNotification('产品数据删除成功！', 'success'); selectedProductIds.delete(id); }
    catch (err) { console.error("删除失败: ", err); showNotification('删除失败，请检查控制台。', 'error'); }
}

// bulk delete buttons
storeDeleteSelectedBtn.addEventListener('click', () => deleteData('amazonSeller', Array.from(selectedStoreIds)));
keywordDeleteSelectedBtn.addEventListener('click', () => deleteData('amazonKeywords', Array.from(selectedKeywordIds)));
productDeleteSelectedBtn.addEventListener('click', () => deleteData('amazonProducts', Array.from(selectedProductIds)));

// select-all behavior based on current filtered results
storeSelectAll.addEventListener('change', (e) => {
    const isChecked = e.target.checked; const current = getFilteredSortedStores().map(i => i.id);
    if (isChecked) current.forEach(id => selectedStoreIds.add(id)); else current.forEach(id => selectedStoreIds.delete(id));
    renderStoreTable();
});
keywordSelectAll.addEventListener('change', (e) => {
    const isChecked = e.target.checked; const current = getFilteredSortedKeywords().map(i => i.id);
    if (isChecked) current.forEach(id => selectedKeywordIds.add(id)); else current.forEach(id => selectedKeywordIds.delete(id));
    renderKeywordTable();
});
productSelectAll.addEventListener('change', (e) => {
    const isChecked = e.target.checked; const current = getFilteredSortedProducts().map(i => i.id);
    if (isChecked) current.forEach(id => selectedProductIds.add(id)); else current.forEach(id => selectedProductIds.delete(id));
    renderProductTable();
});

// --- Tab switching (avoid unnecessary processing) ---
storesTab.addEventListener('click', () => {
    if (storesTab.classList.contains('active')) return;
    storesTab.classList.add('active'); keywordsTab.classList.remove('active'); productsTab.classList.remove('active');
    storesView.classList.remove('hidden'); keywordsView.classList.add('hidden'); productsView.classList.add('hidden');
    processStoreData(); updateSortIcon(ratingHeader, storeSortDir);
});
keywordsTab.addEventListener('click', () => {
    if (keywordsTab.classList.contains('active')) return;
    keywordsTab.classList.add('active'); storesTab.classList.remove('active'); productsTab.classList.remove('active');
    keywordsView.classList.remove('hidden'); storesView.classList.add('hidden'); productsView.classList.add('hidden');
    processKeywordData(); updateSortIcon(keywordDateHeader, keywordSortDir);
});
productsTab.addEventListener('click', () => {
    if (productsTab.classList.contains('active')) return;
    productsTab.classList.add('active'); storesTab.classList.remove('active'); keywordsTab.classList.remove('active');
    productsView.classList.remove('hidden'); storesView.classList.add('hidden'); keywordsView.classList.add('hidden');
    processProductData(); updateSortIcon(productDateHeader, productSortDir);
});

// --- Process functions (render UI) ---
function processStoreData() { renderSiteFilters(storeFiltersDiv, Array.from(storeData.values()), 'store'); renderStoreTable(); }
function processKeywordData() { renderSiteFilters(keywordFiltersDiv, Array.from(keywordData.values()), 'keyword'); renderKeywordTable(); }
function processProductData() { renderSiteFilters(productFiltersDiv, Array.from(productData.values()), 'product'); renderProductTable(); }

// --- Initial load: if already signed in, start listeners (auth.onAuthStateChanged handles it) ---

// --- End of file ---
